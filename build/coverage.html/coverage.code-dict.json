{"/home/travis/build/npmtest/node-npmtest-v8-debug/test.js":"/* istanbul instrument in package npmtest_v8_debug */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-v8-debug/lib.npmtest_v8_debug.js":"/* istanbul instrument in package npmtest_v8_debug */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_v8_debug = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_v8_debug = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-v8-debug/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-v8-debug && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_v8_debug */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_v8_debug\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_v8_debug.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_v8_debug.rollup.js'] =\n            local.assetsDict['/assets.npmtest_v8_debug.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_v8_debug.__dirname + '/lib.npmtest_v8_debug.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/v8-debug.js":"var binary = require('node-pre-gyp');\nvar fs = require('fs');\nvar path = require('path');\nvar binding_path = binary.find(path.resolve(path.join(__dirname,'./package.json')));\nvar binding = require(binding_path);\nvar EventEmitter = require('events').EventEmitter;\nvar inherits = require('util').inherits;\nvar extend = require('util')._extend;\n\nvar NODE_NEXT = require('./tools/NODE_NEXT');\n\n// Don't cache debugger module\ndelete require.cache[module.id];\n\nfunction InjectedScriptDir(link) {\n  return require.resolve(__dirname + '/InjectedScript/' + link);\n};\nvar DebuggerScriptLink = InjectedScriptDir('DebuggerScript.js');\nvar InjectedScriptLink = InjectedScriptDir('InjectedScriptSource.js');\nvar InjectedScriptHostLink = InjectedScriptDir('InjectedScriptHost.js');\n\nvar overrides = {\n  extendedProcessDebugJSONRequestHandles_: {},\n  extendedProcessDebugJSONRequestAsyncHandles_: {},\n  extendedProcessDebugJSONRequest_: function(json_request) {\n    var request;  // Current request.\n    var response;  // Generated response.\n    try {\n      try {\n        // Convert the JSON string to an object.\n        request = JSON.parse(json_request);\n\n        var handle = this.extendedProcessDebugJSONRequestHandles_[request.command];\n        var asyncHandle = this.extendedProcessDebugJSONRequestAsyncHandles_[request.command];\n        var asyncResponse;\n\n        if (!handle && !asyncHandle) return;\n\n        // Create an initial response.\n        response = this.createResponse(request);\n\n        if (request.arguments) {\n          var args = request.arguments;\n          if (args.maxStringLength !== undefined) {\n            response.setOption('maxStringLength', args.maxStringLength);\n          }\n          if (args.asyncResponse) {\n            asyncResponse = args.asyncResponse;\n          }\n        }\n\n        if (asyncHandle) {\n          if (asyncResponse) return JSON.stringify(asyncResponse);\n\n          asyncHandle.call(this, request, response, function(error) {\n            sendCommand(request.command, {\n              asyncResponse: error || response\n            });\n          }.bind(this));\n\n          return '{\"seq\":0,\"type\":\"response\",\"success\":true}';\n        }\n\n        handle.call(this, request, response);\n      } catch (e) {\n        // If there is no response object created one (without command).\n        if (!response) {\n          response = this.createResponse();\n        }\n        response.success = false;\n        response.message = e.toString();\n      }\n\n      // Return the response as a JSON encoded string.\n      try {\n        if (response.running !== undefined) {\n          // Response controls running state.\n          this.running_ = response.running;\n        }\n        response.running = this.running_;\n        return JSON.stringify(response);\n      } catch (e) {\n        // Failed to generate response - return generic error.\n        return '{\"seq\":' + response.seq + ',' +\n                '\"request_seq\":' + request.seq + ',' +\n                '\"type\":\"response\",' +\n                '\"success\":false,' +\n                '\"message\":\"Internal error: ' + e.toString() + '\"}';\n      }\n    } catch (e) {\n      // Failed in one of the catch blocks above - most generic error.\n      return '{\"seq\":0,\"type\":\"response\",\"success\":false,\"message\":\"Internal error\"}';\n    }\n  },\n  processDebugRequest: function WRAPPED_BY_NODE_INSPECTOR(request) {\n    return (this.extendedProcessDebugJSONRequest_\n      && this.extendedProcessDebugJSONRequest_(request))\n      || this.processDebugJSONRequest(request);\n  }\n};\n\ninherits(V8Debug, EventEmitter);\nfunction V8Debug() {\n  this._webkitProtocolEnabled = false;\n\n  // NOTE: Call `_setDebugEventListener` before all other changes in Debug Context.\n  // After node 0.12.0 this function serves to allocate Debug Context\n  // like a persistent value, that saves all our changes.\n  this._setDebugEventListener();\n  this._wrapDebugCommandProcessor();\n\n  this.once('close', function() {\n    this._unwrapDebugCommandProcessor();\n    this._unsetDebugEventListener();\n    process.nextTick(function() {\n      this.removeAllListeners();\n    }.bind(this));\n  });\n}\n\nV8Debug.prototype._setDebugEventListener = function() {\n  var Debug = this.get('Debug');\n  Debug.setListener(function(_, execState, event) {\n    // TODO(3y3): Handle events here\n  });\n};\n\nV8Debug.prototype._unsetDebugEventListener = function() {\n  var Debug = this.get('Debug');\n  Debug.setListener(null);\n};\n\nV8Debug.prototype._wrapDebugCommandProcessor = function() {\n  var proto = this.get('DebugCommandProcessor.prototype');\n  overrides.processDebugRequest_ = proto.processDebugRequest;\n  extend(proto, overrides);\n  overrides.extendedProcessDebugJSONRequestHandles_['disconnect'] = function(request, response) {\n    this.emit('close');\n    this.processDebugJSONRequest(request);\n  }.bind(this);\n};\n\nV8Debug.prototype._unwrapDebugCommandProcessor = function() {\n  var proto = this.get('DebugCommandProcessor.prototype');\n  proto.processDebugRequest = proto.processDebugRequest_;\n  delete proto.processDebugRequest_;\n  delete proto.extendedProcessDebugJSONRequest_;\n  delete proto.extendedProcessDebugJSONRequestHandles_;\n  delete proto.extendedProcessDebugJSONRequestAsyncHandles_;\n};\n\nV8Debug.prototype.register =\nV8Debug.prototype.registerCommand = function(name, func) {\n  overrides.extendedProcessDebugJSONRequestHandles_[name] = func;\n};\n\nV8Debug.prototype.registerAsync =\nV8Debug.prototype.registerAsyncCommand = function(name, func) {\n  overrides.extendedProcessDebugJSONRequestAsyncHandles_[name] = func;\n};\n\nV8Debug.prototype.command =\nV8Debug.prototype.sendCommand =\nV8Debug.prototype.emitEvent = sendCommand;\nfunction sendCommand(name, attributes, userdata) {\n  var message = {\n    seq: 0,\n    type: 'request',\n    command: name,\n    arguments: attributes || {}\n  };\n  binding.sendCommand(JSON.stringify(message));\n};\n\nV8Debug.prototype.commandToEvent = function(request, response) {\n  response.type = 'event';\n  response.event = response.command;\n  response.body = request.arguments || {};\n  delete response.command;\n  delete response.request_seq;\n};\n\nV8Debug.prototype.registerEvent = function(name) {\n  overrides.extendedProcessDebugJSONRequestHandles_[name] = this.commandToEvent;\n};\n\nV8Debug.prototype.get =\nV8Debug.prototype.runInDebugContext = function(script) {\n  if (typeof script == 'function') script = script.toString() + '()';\n\n  script = /\\);$/.test(script) ? script : '(' + script + ');';\n\n  return binding.runScript(script);\n};\n\nV8Debug.prototype.getFromFrame = function(index, value) {\n  var result;\n\n  binding.call(function(execState) {\n    var _index = index + 1;\n    var _count = execState.frameCount();\n    if (_count > _index + 1 ) {\n      var frame = execState.frame(_index + 1);\n      _count = frame.scopeCount();\n      _index = 0;\n      while (_count --> 0) {\n        var scope = frame.scope(_index).scopeObject().value();\n        if (scope[value]) {\n          result = scope[value];\n          return;\n        }\n      }\n    }\n  });\n\n  return result;\n};\n\nV8Debug.prototype.enableWebkitProtocol = function() {\n  if (!NODE_NEXT) {\n    throw new Error('WebKit protocol is not supported on target node version (' + process.version + ')');\n  }\n\n  if (this._webkitProtocolEnabled) return;\n\n  var DebuggerScriptSource,\n      DebuggerScript,\n      InjectedScriptSource,\n      InjectedScript,\n      InjectedScriptHostSource,\n      InjectedScriptHost;\n\n  function prepareSource(source) {\n    return 'var ToggleMirrorCache = ToggleMirrorCache || function() {};\\n' +\n    '(function() {' +\n      ('' + source).replace(/^.*?\"use strict\";(\\r?\\n.*?)*\\(/m, '\\r\\n\"use strict\";\\nreturn (') +\n    '}());';\n  }\n\n  DebuggerScriptSource = prepareSource(fs.readFileSync(DebuggerScriptLink, 'utf8'));\n  DebuggerScript = this.runInDebugContext(DebuggerScriptSource);\n\n  InjectedScriptSource = prepareSource(fs.readFileSync(InjectedScriptLink, 'utf8'));\n  InjectedScript = this.runInDebugContext(InjectedScriptSource);\n\n  InjectedScriptHostSource = prepareSource(fs.readFileSync(InjectedScriptHostLink, 'utf8'));\n  InjectedScriptHost = this.runInDebugContext(InjectedScriptHostSource)(binding, DebuggerScript);\n\n  var injectedScript = InjectedScript(InjectedScriptHost, global, 1);\n\n  this.registerAgentCommand = function(command, parameters, callback) {\n    this.registerCommand(command, new WebkitProtocolCallback(parameters, callback));\n  };\n\n  this._webkitProtocolEnabled = true;\n\n  function WebkitProtocolCallback(argsList, callback) {\n    return function(request, response) {\n      InjectedScriptHost.execState = this.exec_state_;\n\n      var args = argsList.map(function(name) {\n        return request.arguments[name];\n      });\n\n      callback.call(this, args, response, injectedScript, DebuggerScript);\n\n      InjectedScriptHost.execState = null;\n    }\n  }\n};\n\nV8Debug.prototype.registerAgentCommand = function(command, parameters, callback) {\n  throw new Error('Use \"enableWebkitProtocol\" before using this method');\n};\n\nmodule.exports = new V8Debug();\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/tools/NODE_NEXT.js":"return module.exports = process.versions.modules > 45;\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/InjectedScript/DebuggerScript.js":"/*\n * Copyright (C) 2010 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\"use strict\";\n\n(function () {\n\nvar DebuggerScript = {};\n\nDebuggerScript.PauseOnExceptionsState = {\n    DontPauseOnExceptions: 0,\n    PauseOnAllExceptions: 1,\n    PauseOnUncaughtExceptions: 2\n};\n\nDebuggerScript.ScopeInfoDetails = {\n    AllScopes: 0,\n    FastAsyncScopes: 1,\n    NoScopes: 2\n};\n\nDebuggerScript._pauseOnExceptionsState = DebuggerScript.PauseOnExceptionsState.DontPauseOnExceptions;\nDebug.clearBreakOnException();\nDebug.clearBreakOnUncaughtException();\n\nDebuggerScript.getAfterCompileScript = function(eventData)\n{\n    return DebuggerScript._formatScript(eventData.script_.script_);\n}\n\nDebuggerScript.getWorkerScripts = function()\n{\n    var result = [];\n    var scripts = Debug.scripts();\n    for (var i = 0; i < scripts.length; ++i) {\n        var script = scripts[i];\n        // Workers don't share same V8 heap now so there is no need to complicate stuff with\n        // the context id like we do to discriminate between scripts from different pages.\n        // However we need to filter out v8 native scripts.\n        if (script.context_data && script.context_data === \"worker\")\n            result.push(DebuggerScript._formatScript(script));\n    }\n    return result;\n}\n\nDebuggerScript.getFunctionScopes = function(fun)\n{\n    var mirror = MakeMirror(fun);\n    var count = mirror.scopeCount();\n    if (count == 0)\n        return null;\n    var result = [];\n    for (var i = 0; i < count; i++) {\n        var scopeDetails = mirror.scope(i).details();\n        var scopeObject = DebuggerScript._buildScopeObject(scopeDetails.type(), scopeDetails.object());\n        if (!scopeObject)\n            continue;\n        result.push({\n            type: scopeDetails.type(),\n            object: scopeObject\n        });\n    }\n    return result;\n}\n\nDebuggerScript.getCollectionEntries = function(object)\n{\n    var mirror = MakeMirror(object, true /* transient */);\n    if (mirror.isMap())\n        return mirror.entries();\n    if (mirror.isSet() || mirror.isIterator()) {\n        var result = [];\n        var values = mirror.isSet() ? mirror.values() : mirror.preview();\n        for (var i = 0; i < values.length; ++i)\n            result.push({ value: values[i] });\n        return result;\n    }\n}\n\nDebuggerScript.getInternalProperties = function(value)\n{\n    var properties = ObjectMirror.GetInternalProperties(value);\n    var result = [];\n    for (var i = 0; i < properties.length; i++) {\n        var mirror = properties[i];\n        result.push({\n            name: mirror.name(),\n            value: mirror.value().value()\n        });\n    }\n    return result;\n}\n\nDebuggerScript.setFunctionVariableValue = function(functionValue, scopeIndex, variableName, newValue)\n{\n    var mirror = MakeMirror(functionValue);\n    if (!mirror.isFunction())\n        throw new Error(\"Function value has incorrect type\");\n    return DebuggerScript._setScopeVariableValue(mirror, scopeIndex, variableName, newValue);\n}\n\nDebuggerScript._setScopeVariableValue = function(scopeHolder, scopeIndex, variableName, newValue)\n{\n    var scopeMirror = scopeHolder.scope(scopeIndex);\n    if (!scopeMirror)\n        throw new Error(\"Incorrect scope index\");\n    scopeMirror.setVariableValue(variableName, newValue);\n    return undefined;\n}\n\nDebuggerScript.getScripts = function(contextData)\n{\n    var result = [];\n\n    if (!contextData)\n        return result;\n    var comma = contextData.indexOf(\",\");\n    if (comma === -1)\n        return result;\n    // Context data is a string in the following format:\n    // (\"page\"|\"injected\")\",\"<page id>\n    var idSuffix = contextData.substring(comma); // including the comma\n\n    var scripts = Debug.scripts();\n    for (var i = 0; i < scripts.length; ++i) {\n        var script = scripts[i];\n        if (script.context_data && script.context_data.lastIndexOf(idSuffix) != -1)\n            result.push(DebuggerScript._formatScript(script));\n    }\n    return result;\n}\n\nDebuggerScript._formatScript = function(script)\n{\n    var lineEnds = script.line_ends;\n    var lineCount = lineEnds.length;\n    var endLine = script.line_offset + lineCount - 1;\n    var endColumn;\n    // V8 will not count last line if script source ends with \\n.\n    if (script.source[script.source.length - 1] === '\\n') {\n        endLine += 1;\n        endColumn = 0;\n    } else {\n        if (lineCount === 1)\n            endColumn = script.source.length + script.column_offset;\n        else\n            endColumn = script.source.length - (lineEnds[lineCount - 2] + 1);\n    }\n\n    return {\n        id: script.id,\n        name: script.nameOrSourceURL(),\n        sourceURL: script.source_url,\n        sourceMappingURL: script.source_mapping_url,\n        source: script.source,\n        startLine: script.line_offset,\n        startColumn: script.column_offset,\n        endLine: endLine,\n        endColumn: endColumn,\n        isContentScript: !!script.context_data && script.context_data.indexOf(\"injected\") == 0\n    };\n}\n\nDebuggerScript.setBreakpoint = function(execState, info)\n{\n    var positionAlignment = info.interstatementLocation ? Debug.BreakPositionAlignment.BreakPosition : Debug.BreakPositionAlignment.Statement;\n    var breakId = Debug.setScriptBreakPointById(info.sourceID, info.lineNumber, info.columnNumber, info.condition, undefined, positionAlignment);\n\n    var locations = Debug.findBreakPointActualLocations(breakId);\n    if (!locations.length)\n        return undefined;\n    info.lineNumber = locations[0].line;\n    info.columnNumber = locations[0].column;\n    return breakId.toString();\n}\n\nDebuggerScript.removeBreakpoint = function(execState, info)\n{\n    Debug.findBreakPoint(info.breakpointId, true);\n}\n\nDebuggerScript.pauseOnExceptionsState = function()\n{\n    return DebuggerScript._pauseOnExceptionsState;\n}\n\nDebuggerScript.setPauseOnExceptionsState = function(newState)\n{\n    DebuggerScript._pauseOnExceptionsState = newState;\n\n    if (DebuggerScript.PauseOnExceptionsState.PauseOnAllExceptions === newState)\n        Debug.setBreakOnException();\n    else\n        Debug.clearBreakOnException();\n\n    if (DebuggerScript.PauseOnExceptionsState.PauseOnUncaughtExceptions === newState)\n        Debug.setBreakOnUncaughtException();\n    else\n        Debug.clearBreakOnUncaughtException();\n}\n\nDebuggerScript.frameCount = function(execState)\n{\n    return execState.frameCount();\n}\n\nDebuggerScript.currentCallFrame = function(execState, data)\n{\n    var maximumLimit = data >> 2;\n    var scopeDetailsLevel = data & 3;\n\n    var frameCount = execState.frameCount();\n    if (maximumLimit && maximumLimit < frameCount)\n        frameCount = maximumLimit;\n    var topFrame = undefined;\n    for (var i = frameCount - 1; i >= 0; i--) {\n        var frameMirror = execState.frame(i);\n        topFrame = DebuggerScript._frameMirrorToJSCallFrame(frameMirror, topFrame, scopeDetailsLevel);\n    }\n    return topFrame;\n}\n\nDebuggerScript.currentCallFrameByIndex = function(execState, index)\n{\n    if (index < 0)\n        return undefined;\n    var frameCount = execState.frameCount();\n    if (index >= frameCount)\n        return undefined;\n    return DebuggerScript._frameMirrorToJSCallFrame(execState.frame(index), undefined, DebuggerScript.ScopeInfoDetails.NoScopes);\n}\n\nDebuggerScript.stepIntoStatement = function(execState)\n{\n    execState.prepareStep(Debug.StepAction.StepIn, 1);\n}\n\nDebuggerScript.stepFrameStatement = function(execState)\n{\n    execState.prepareStep(Debug.StepAction.StepFrame, 1);\n}\n\nDebuggerScript.stepOverStatement = function(execState, callFrame)\n{\n    execState.prepareStep(Debug.StepAction.StepNext, 1);\n}\n\nDebuggerScript.stepOutOfFunction = function(execState, callFrame)\n{\n    execState.prepareStep(Debug.StepAction.StepOut, 1);\n}\n\n// Returns array in form:\n//      [ 0, <v8_result_report> ] in case of success\n//   or [ 1, <general_error_message>, <compiler_message>, <line_number>, <column_number> ] in case of compile error, numbers are 1-based.\n// or throws exception with message.\nDebuggerScript.liveEditScriptSource = function(scriptId, newSource, preview)\n{\n    var scripts = Debug.scripts();\n    var scriptToEdit = null;\n    for (var i = 0; i < scripts.length; i++) {\n        if (scripts[i].id == scriptId) {\n            scriptToEdit = scripts[i];\n            break;\n        }\n    }\n    if (!scriptToEdit)\n        throw(\"Script not found\");\n\n    var changeLog = [];\n    try {\n        var result = Debug.LiveEdit.SetScriptSource(scriptToEdit, newSource, preview, changeLog);\n        return [0, result];\n    } catch (e) {\n        if (e instanceof Debug.LiveEdit.Failure && \"details\" in e) {\n            var details = e.details;\n            if (details.type === \"liveedit_compile_error\") {\n                var startPosition = details.position.start;\n                return [1, String(e), String(details.syntaxErrorMessage), Number(startPosition.line), Number(startPosition.column)];\n            }\n        }\n        throw e;\n    }\n}\n\nDebuggerScript.clearBreakpoints = function(execState, info)\n{\n    Debug.clearAllBreakPoints();\n}\n\nDebuggerScript.setBreakpointsActivated = function(execState, info)\n{\n    Debug.debuggerFlags().breakPointsActive.setValue(info.enabled);\n}\n\nDebuggerScript.getScriptSource = function(eventData)\n{\n    return eventData.script().source();\n}\n\nDebuggerScript.setScriptSource = function(eventData, source)\n{\n    if (eventData.script().data() === \"injected-script\")\n        return;\n    eventData.script().setSource(source);\n}\n\nDebuggerScript.getScriptName = function(eventData)\n{\n    return eventData.script().script_.nameOrSourceURL();\n}\n\nDebuggerScript.getBreakpointNumbers = function(eventData)\n{\n    var breakpoints = eventData.breakPointsHit();\n    var numbers = [];\n    if (!breakpoints)\n        return numbers;\n\n    for (var i = 0; i < breakpoints.length; i++) {\n        var breakpoint = breakpoints[i];\n        var scriptBreakPoint = breakpoint.script_break_point();\n        numbers.push(scriptBreakPoint ? scriptBreakPoint.number() : breakpoint.number());\n    }\n    return numbers;\n}\n\nDebuggerScript.isEvalCompilation = function(eventData)\n{\n    var script = eventData.script();\n    return (script.compilationType() === Debug.ScriptCompilationType.Eval);\n}\n\n// NOTE: This function is performance critical, as it can be run on every\n// statement that generates an async event (like addEventListener) to support\n// asynchronous call stacks. Thus, when possible, initialize the data lazily.\nDebuggerScript._frameMirrorToJSCallFrame = function(frameMirror, callerFrame, scopeDetailsLevel)\n{\n    // Stuff that can not be initialized lazily (i.e. valid while paused with a valid break_id).\n    // The frameMirror and scopeMirror can be accessed only while paused on the debugger.\n    var frameDetails = frameMirror.details();\n\n    var funcObject = frameDetails.func();\n    var sourcePosition = frameDetails.sourcePosition();\n    var thisObject = frameDetails.receiver();\n\n    var isAtReturn = !!frameDetails.isAtReturn();\n    var returnValue = isAtReturn ? frameDetails.returnValue() : undefined;\n\n    var scopeMirrors = (scopeDetailsLevel === DebuggerScript.ScopeInfoDetails.NoScopes ? [] : frameMirror.allScopes(scopeDetailsLevel === DebuggerScript.ScopeInfoDetails.FastAsyncScopes));\n    var scopeTypes = new Array(scopeMirrors.length);\n    var scopeObjects = new Array(scopeMirrors.length);\n    for (var i = 0; i < scopeMirrors.length; ++i) {\n        var scopeDetails = scopeMirrors[i].details();\n        scopeTypes[i] = scopeDetails.type();\n        scopeObjects[i] = scopeDetails.object();\n    }\n\n    // Calculated lazily.\n    var scopeChain;\n    var funcMirror;\n    var location;\n\n    function lazyScopeChain()\n    {\n        if (!scopeChain) {\n            scopeChain = [];\n            for (var i = 0, j = 0; i < scopeObjects.length; ++i) {\n                var scopeObject = DebuggerScript._buildScopeObject(scopeTypes[i], scopeObjects[i]);\n                if (scopeObject) {\n                    scopeTypes[j] = scopeTypes[i];\n                    scopeChain[j] = scopeObject;\n                    ++j;\n                }\n            }\n            scopeTypes.length = scopeChain.length;\n            scopeObjects = null; // Free for GC.\n        }\n        return scopeChain;\n    }\n\n    function lazyScopeTypes()\n    {\n        if (!scopeChain)\n            lazyScopeChain();\n        return scopeTypes;\n    }\n\n    function ensureFuncMirror()\n    {\n        if (!funcMirror) {\n            funcMirror = MakeMirror(funcObject);\n            if (!funcMirror.isFunction())\n                funcMirror = new UnresolvedFunctionMirror(funcObject);\n        }\n        return funcMirror;\n    }\n\n    function ensureLocation()\n    {\n        if (!location) {\n            var script = ensureFuncMirror().script();\n            if (script)\n                location = script.locationFromPosition(sourcePosition, true);\n            if (!location)\n                location = { line: 0, column: 0 };\n        }\n        return location;\n    }\n\n    function line()\n    {\n        return ensureLocation().line;\n    }\n\n    function column()\n    {\n        return ensureLocation().column;\n    }\n\n    function sourceID()\n    {\n        var script = ensureFuncMirror().script();\n        return script && script.id();\n    }\n\n    function scriptName()\n    {\n        var script = ensureFuncMirror().script();\n        return script && script.name();\n    }\n\n    function functionName()\n    {\n        var func = ensureFuncMirror();\n        if (!func.resolved())\n            return undefined;\n        var displayName;\n        var valueMirror = func.property(\"displayName\").value();\n        if (valueMirror && valueMirror.isString())\n            displayName = valueMirror.value();\n        return displayName || func.name() || func.inferredName();\n    }\n\n    function evaluate(expression, scopeExtension)\n    {\n        return frameMirror.evaluate(expression, false, scopeExtension).value();\n    }\n\n    function restart()\n    {\n        return Debug.LiveEdit.RestartFrame(frameMirror);\n    }\n\n    function setVariableValue(scopeNumber, variableName, newValue)\n    {\n        return DebuggerScript._setScopeVariableValue(frameMirror, scopeNumber, variableName, newValue);\n    }\n\n    function stepInPositions()\n    {\n        var stepInPositionsV8 = frameMirror.stepInPositions();\n        var stepInPositionsProtocol;\n        if (stepInPositionsV8) {\n            stepInPositionsProtocol = [];\n            var script = ensureFuncMirror().script();\n            if (script) {\n                var scriptId = String(script.id());\n                for (var i = 0; i < stepInPositionsV8.length; i++) {\n                    var item = {\n                        scriptId: scriptId,\n                        lineNumber: stepInPositionsV8[i].position.line,\n                        columnNumber: stepInPositionsV8[i].position.column\n                    };\n                    stepInPositionsProtocol.push(item);\n                }\n            }\n        }\n        return JSON.stringify(stepInPositionsProtocol);\n    }\n\n    return {\n        \"sourceID\": sourceID,\n        \"line\": line,\n        \"column\": column,\n        \"scriptName\": scriptName,\n        \"functionName\": functionName,\n        \"thisObject\": thisObject,\n        \"scopeChain\": lazyScopeChain,\n        \"scopeType\": lazyScopeTypes,\n        \"evaluate\": evaluate,\n        \"caller\": callerFrame,\n        \"restart\": restart,\n        \"setVariableValue\": setVariableValue,\n        \"stepInPositions\": stepInPositions,\n        \"isAtReturn\": isAtReturn,\n        \"returnValue\": returnValue\n    };\n}\n\nDebuggerScript._buildScopeObject = function(scopeType, scopeObject)\n{\n    var result;\n    switch (scopeType) {\n    case ScopeType.Local:\n    case ScopeType.Closure:\n    case ScopeType.Catch:\n    case ScopeType.Block:\n    case ScopeType.Script:\n        // For transient objects we create a \"persistent\" copy that contains\n        // the same properties.\n        // Reset scope object prototype to null so that the proto properties\n        // don't appear in the local scope section.\n        var properties = MakeMirror(scopeObject, true /* transient */).properties();\n        // Almost always Script scope will be empty, so just filter out that noise.\n        // Also drop empty Block scopes, should we get any.\n        if (!properties.length && (scopeType === ScopeType.Script || scopeType === ScopeType.Block))\n            break;\n        result = { __proto__: null };\n        for (var j = 0; j < properties.length; j++) {\n            var name = properties[j].name();\n            if (name.charAt(0) === \".\")\n                continue; // Skip internal variables like \".arguments\"\n            result[name] = properties[j].value_;\n        }\n        break;\n    case ScopeType.Global:\n    case ScopeType.With:\n        result = scopeObject;\n        break;\n    }\n    return result;\n}\n\nDebuggerScript.getPromiseDetails = function(eventData)\n{\n    return {\n        \"promise\": eventData.promise().value(),\n        \"parentPromise\": eventData.parentPromise().value(),\n        \"status\": eventData.status()\n    };\n}\n\n// We never resolve Mirror by its handle so to avoid memory leaks caused by Mirrors in the cache we disable it.\nToggleMirrorCache(false);\n\nreturn DebuggerScript;\n})();\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/InjectedScript/InjectedScriptHost.js":"\"use strict\";\n\n(function (binding, DebuggerScript) {\n  function InjectedScriptHost() {}\n  \n  InjectedScriptHost.prototype = binding.InjectedScriptHost;\n\n  InjectedScriptHost.prototype.isHTMLAllCollection = function(object) {\n    //We don't have `all` collection in NodeJS\n    return false;\n  };\n\n  InjectedScriptHost.prototype.suppressWarningsAndCallFunction = function(func, receiver, args) {\n    return this.callFunction(func, receiver, args);\n  };\n\n  InjectedScriptHost.prototype.functionDetails = function(fun) {\n    var details = this.functionDetailsWithoutScopes(fun);\n    var scopes = DebuggerScript.getFunctionScopes(fun);\n    \n    if (scopes && scopes.length) {\n      details.rawScopes = scopes;\n    }\n    \n    return details;\n  };\n\n  InjectedScriptHost.prototype.getInternalProperties = function(value) {\n    return DebuggerScript.getInternalProperties(value);\n  };\n  \n  return new InjectedScriptHost();\n});\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/InjectedScript/InjectedScriptSource.js":"/*\n * Copyright (C) 2007 Apple Inc.  All rights reserved.\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\"use strict\";\n\n/**\n * @param {!InjectedScriptHostClass} InjectedScriptHost\n * @param {!Window|!WorkerGlobalScope} inspectedGlobalObject\n * @param {number} injectedScriptId\n */\n(function (InjectedScriptHost, inspectedGlobalObject, injectedScriptId) {\n\n/**\n * Protect against Object overwritten by the user code.\n * @suppress {duplicate}\n */\nvar Object = /** @type {function(new:Object, *=)} */ ({}.constructor);\n\n/**\n * @param {!Array.<T>} array\n * @param {...} var_args\n * @template T\n */\nfunction push(array, var_args)\n{\n    for (var i = 1; i < arguments.length; ++i)\n        array[array.length] = arguments[i];\n}\n\n/**\n * @param {(!Arguments.<T>|!NodeList)} array\n * @param {number=} index\n * @return {!Array.<T>}\n * @template T\n */\nfunction slice(array, index)\n{\n    var result = [];\n    for (var i = index || 0, j = 0; i < array.length; ++i, ++j)\n        result[j] = array[i];\n    return result;\n}\n\n/**\n * @param {!Array.<T>} array1\n * @param {!Array.<T>} array2\n * @return {!Array.<T>}\n * @template T\n */\nfunction concat(array1, array2)\n{\n    var result = [];\n    for (var i = 0; i < array1.length; ++i)\n        push(result, array1[i]);\n    for (var i = 0; i < array2.length; ++i)\n        push(result, array2[i]);\n    return result;\n}\n\n/**\n * @param {*} obj\n * @return {string}\n * @suppress {uselessCode}\n */\nfunction toString(obj)\n{\n    // We don't use String(obj) because String could be overridden.\n    // Also the (\"\" + obj) expression may throw.\n    try {\n        return \"\" + obj;\n    } catch (e) {\n        var name = InjectedScriptHost.internalConstructorName(obj) || InjectedScriptHost.subtype(obj) || (typeof obj);\n        return \"#<\" + name + \">\";\n    }\n}\n\n/**\n * @param {*} obj\n * @return {string}\n */\nfunction toStringDescription(obj)\n{\n    if (typeof obj === \"number\" && obj === 0 && 1 / obj < 0)\n        return \"-0\"; // Negative zero.\n    return toString(obj);\n}\n\n/**\n * Please use this bind, not the one from Function.prototype\n * @param {function(...)} func\n * @param {?Object} thisObject\n * @param {...} var_args\n * @return {function(...)}\n */\nfunction bind(func, thisObject, var_args)\n{\n    var args = slice(arguments, 2);\n\n    /**\n     * @param {...} var_args\n     */\n    function bound(var_args)\n    {\n        return InjectedScriptHost.callFunction(func, thisObject, concat(args, slice(arguments)));\n    }\n    bound.toString = function()\n    {\n        return \"bound: \" + toString(func);\n    };\n    return bound;\n}\n\n/**\n * @param {T} obj\n * @return {T}\n * @template T\n */\nfunction nullifyObjectProto(obj)\n{\n    if (obj && typeof obj === \"object\")\n        obj.__proto__ = null;\n    return obj;\n}\n\n/**\n * @param {number|string} obj\n * @return {boolean}\n */\nfunction isUInt32(obj)\n{\n    if (typeof obj === \"number\")\n        return obj >>> 0 === obj && (obj > 0 || 1 / obj > 0);\n    return \"\" + (obj >>> 0) === obj;\n}\n\n/**\n * FireBug's array detection.\n * @param {*} obj\n * @return {boolean}\n */\nfunction isArrayLike(obj)\n{\n    if (typeof obj !== \"object\")\n        return false;\n    try {\n        if (typeof obj.splice === \"function\") {\n            var len = obj.length;\n            return typeof len === \"number\" && isUInt32(len);\n        }\n    } catch (e) {\n    }\n    return false;\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nfunction max(a, b)\n{\n    return a > b ? a : b;\n}\n\n/**\n * FIXME: Remove once ES6 is supported natively by JS compiler.\n * @param {*} obj\n * @return {boolean}\n */\nfunction isSymbol(obj)\n{\n    var type = typeof obj;\n    return (type === \"symbol\");\n}\n\n/**\n * @param {string} str\n * @param {string} searchElement\n * @param {number=} fromIndex\n * @return {number}\n */\nfunction indexOf(str, searchElement, fromIndex)\n{\n    var len = str.length;\n    var n = fromIndex || 0;\n    var k = max(n >= 0 ? n : len + n, 0);\n\n    while (k < len) {\n        if (str[k] === searchElement)\n            return k;\n        ++k;\n    }\n    return -1;\n}\n\n/**\n * DOM Attributes which have observable side effect on getter, in the form of\n *   {interfaceName1: {attributeName1: true,\n *                     attributeName2: true,\n *                     ...},\n *    interfaceName2: {...},\n *    ...}\n * @type {!Object<string, !Object<string, boolean>>}\n * @const\n */\nvar domAttributesWithObservableSideEffectOnGet = nullifyObjectProto({});\ndomAttributesWithObservableSideEffectOnGet[\"Request\"] = nullifyObjectProto({});\ndomAttributesWithObservableSideEffectOnGet[\"Request\"][\"body\"] = true;\ndomAttributesWithObservableSideEffectOnGet[\"Response\"] = nullifyObjectProto({});\ndomAttributesWithObservableSideEffectOnGet[\"Response\"][\"body\"] = true;\n\n/**\n * @param {!Object} object\n * @param {string} attribute\n * @return {boolean}\n */\nfunction doesAttributeHaveObservableSideEffectOnGet(object, attribute)\n{\n    for (var interfaceName in domAttributesWithObservableSideEffectOnGet) {\n        var isInstance = InjectedScriptHost.suppressWarningsAndCallFunction(function(object, interfaceName) {\n            return /* suppressBlacklist */ typeof inspectedGlobalObject[interfaceName] === \"function\" && object instanceof inspectedGlobalObject[interfaceName];\n        }, null, [object, interfaceName]);\n        if (isInstance) {\n            return attribute in domAttributesWithObservableSideEffectOnGet[interfaceName];\n        }\n    }\n    return false;\n}\n\n/**\n * @constructor\n */\nvar InjectedScript = function()\n{\n}\n\n/**\n * @type {!Object.<string, boolean>}\n * @const\n */\nInjectedScript.primitiveTypes = {\n    \"undefined\": true,\n    \"boolean\": true,\n    \"number\": true,\n    \"string\": true,\n    __proto__: null\n}\n\nInjectedScript.prototype = {\n    /**\n     * @param {*} object\n     * @return {boolean}\n     */\n    isPrimitiveValue: function(object)\n    {\n        // FIXME(33716): typeof document.all is always 'undefined'.\n        return InjectedScript.primitiveTypes[typeof object] && !this._isHTMLAllCollection(object);\n    },\n\n    /**\n     * @param {*} object\n     * @param {string} groupName\n     * @param {boolean} canAccessInspectedGlobalObject\n     * @param {boolean} generatePreview\n     * @return {!RuntimeAgent.RemoteObject}\n     */\n    wrapObject: function(object, groupName, canAccessInspectedGlobalObject, generatePreview)\n    {\n        if (canAccessInspectedGlobalObject)\n            return this._wrapObject(object, groupName, false, generatePreview);\n        return this._fallbackWrapper(object);\n    },\n\n    /**\n     * @param {*} object\n     * @return {!RuntimeAgent.RemoteObject}\n     */\n    _fallbackWrapper: function(object)\n    {\n        var result = { __proto__: null };\n        result.type = typeof object;\n        if (this.isPrimitiveValue(object))\n            result.value = object;\n        else\n            result.description = toString(object);\n        return /** @type {!RuntimeAgent.RemoteObject} */ (result);\n    },\n\n    /**\n     * @param {boolean} canAccessInspectedGlobalObject\n     * @param {!Object} table\n     * @param {!Array.<string>|string|boolean} columns\n     * @return {!RuntimeAgent.RemoteObject}\n     */\n    wrapTable: function(canAccessInspectedGlobalObject, table, columns)\n    {\n        if (!canAccessInspectedGlobalObject)\n            return this._fallbackWrapper(table);\n        var columnNames = null;\n        if (typeof columns === \"string\")\n            columns = [columns];\n        if (InjectedScriptHost.subtype(columns) === \"array\") {\n            columnNames = [];\n            for (var i = 0; i < columns.length; ++i)\n                columnNames[i] = toString(columns[i]);\n        }\n        return this._wrapObject(table, \"console\", false, true, columnNames, true);\n    },\n\n    /**\n     * @param {*} object\n     * @return {*}\n     */\n    _inspect: function(object)\n    {\n        if (arguments.length === 0)\n            return;\n\n        var objectId = this._wrapObject(object, \"\");\n        var hints = { __proto__: null };\n\n        InjectedScriptHost.inspect(objectId, hints);\n        return object;\n    },\n\n    /**\n     * This method cannot throw.\n     * @param {*} object\n     * @param {string=} objectGroupName\n     * @param {boolean=} forceValueType\n     * @param {boolean=} generatePreview\n     * @param {?Array.<string>=} columnNames\n     * @param {boolean=} isTable\n     * @param {boolean=} doNotBind\n     * @param {*=} customObjectConfig\n     * @return {!RuntimeAgent.RemoteObject}\n     * @suppress {checkTypes}\n     */\n    _wrapObject: function(object, objectGroupName, forceValueType, generatePreview, columnNames, isTable, doNotBind, customObjectConfig)\n    {\n        try {\n            return new InjectedScript.RemoteObject(object, objectGroupName, doNotBind, forceValueType, generatePreview, columnNames, isTable, undefined, customObjectConfig);\n        } catch (e) {\n            try {\n                var description = injectedScript._describe(e);\n            } catch (ex) {\n                var description = \"<failed to convert exception to string>\";\n            }\n            return new InjectedScript.RemoteObject(description);\n        }\n    },\n\n    /**\n     * @param {!Object|symbol} object\n     * @param {string=} objectGroupName\n     * @return {string}\n     */\n    _bind: function(object, objectGroupName)\n    {\n        var id = InjectedScriptHost.bind(object, objectGroupName || \"\");\n        return \"{\\\"injectedScriptId\\\":\" + injectedScriptId + \",\\\"id\\\":\" + id + \"}\";\n    },\n\n    /**\n     * @param {string} objectId\n     * @return {!Object}\n     */\n    _parseObjectId: function(objectId)\n    {\n        return nullifyObjectProto(/** @type {!Object} */ (InjectedScriptHost.eval(\"(\" + objectId + \")\")));\n    },\n\n    clearLastEvaluationResult: function()\n    {\n        delete this._lastResult;\n    },\n\n    /**\n     * @param {string} objectId\n     * @param {boolean} ownProperties\n     * @param {boolean} accessorPropertiesOnly\n     * @param {boolean} generatePreview\n     * @return {!Array.<!RuntimeAgent.PropertyDescriptor>|boolean}\n     */\n    getProperties: function(objectId, ownProperties, accessorPropertiesOnly, generatePreview)\n    {\n        var parsedObjectId = this._parseObjectId(objectId);\n        var object = this._objectForId(parsedObjectId);\n        var objectGroupName = InjectedScriptHost.idToObjectGroupName(parsedObjectId.id);\n\n        if (!this._isDefined(object) || isSymbol(object))\n            return false;\n        object = /** @type {!Object} */ (object);\n        var descriptors = [];\n        var iter = this._propertyDescriptors(object, ownProperties, accessorPropertiesOnly, undefined);\n        // Go over properties, wrap object values.\n        for (var descriptor of iter) {\n            if (\"get\" in descriptor)\n                descriptor.get = this._wrapObject(descriptor.get, objectGroupName);\n            if (\"set\" in descriptor)\n                descriptor.set = this._wrapObject(descriptor.set, objectGroupName);\n            if (\"value\" in descriptor)\n                descriptor.value = this._wrapObject(descriptor.value, objectGroupName, false, generatePreview);\n            if (!(\"configurable\" in descriptor))\n                descriptor.configurable = false;\n            if (!(\"enumerable\" in descriptor))\n                descriptor.enumerable = false;\n            if (\"symbol\" in descriptor)\n                descriptor.symbol = this._wrapObject(descriptor.symbol, objectGroupName);\n            push(descriptors, descriptor);\n        }\n        return descriptors;\n    },\n\n    /**\n     * @param {string} objectId\n     * @return {!Array.<!Object>|boolean}\n     */\n    getInternalProperties: function(objectId)\n    {\n        var parsedObjectId = this._parseObjectId(objectId);\n        var object = this._objectForId(parsedObjectId);\n        var objectGroupName = InjectedScriptHost.idToObjectGroupName(parsedObjectId.id);\n        if (!this._isDefined(object) || isSymbol(object))\n            return false;\n        object = /** @type {!Object} */ (object);\n        var descriptors = [];\n        var internalProperties = InjectedScriptHost.getInternalProperties(object);\n        if (internalProperties) {\n            for (var i = 0; i < internalProperties.length; i += 2) {\n                var descriptor = {\n                    name: internalProperties[i],\n                    value: this._wrapObject(internalProperties[i + 1], objectGroupName),\n                    __proto__: null\n                };\n                push(descriptors, descriptor);\n            }\n        }\n        return descriptors;\n    },\n\n    /**\n     * @param {string} functionId\n     * @return {!DebuggerAgent.FunctionDetails|string}\n     */\n    getFunctionDetails: function(functionId)\n    {\n        var parsedFunctionId = this._parseObjectId(functionId);\n        var func = this._objectForId(parsedFunctionId);\n        if (typeof func !== \"function\")\n            return \"Cannot resolve function by id.\";\n        var details = nullifyObjectProto(/** @type {!DebuggerAgent.FunctionDetails} */ (InjectedScriptHost.functionDetails(func)));\n        if (\"rawScopes\" in details) {\n            var objectGroupName = InjectedScriptHost.idToObjectGroupName(parsedFunctionId.id);\n            var rawScopes = details[\"rawScopes\"];\n            delete details[\"rawScopes\"];\n            var scopes = [];\n            for (var i = 0; i < rawScopes.length; ++i)\n                scopes[i] = InjectedScript.CallFrameProxy._createScopeJson(rawScopes[i].type, rawScopes[i].object, objectGroupName);\n            details.scopeChain = scopes;\n        }\n        return details;\n    },\n\n    /**\n     * @param {string} objectId\n     * @return {!DebuggerAgent.GeneratorObjectDetails|string}\n     */\n    getGeneratorObjectDetails: function(objectId)\n    {\n        var parsedObjectId = this._parseObjectId(objectId);\n        var object = this._objectForId(parsedObjectId);\n        if (!object || typeof object !== \"object\")\n            return \"Could not find object with given id\";\n        var details = nullifyObjectProto(/** @type {?DebuggerAgent.GeneratorObjectDetails} */ (InjectedScriptHost.generatorObjectDetails(object)));\n        if (!details)\n            return \"Object is not a generator\";\n        var objectGroupName = InjectedScriptHost.idToObjectGroupName(parsedObjectId.id);\n        details[\"function\"] = this._wrapObject(details[\"function\"], objectGroupName);\n        return details;\n    },\n\n    /**\n     * @param {string} objectId\n     * @return {!Array.<!Object>|string}\n     */\n    getCollectionEntries: function(objectId)\n    {\n        var parsedObjectId = this._parseObjectId(objectId);\n        var object = this._objectForId(parsedObjectId);\n        if (!object || typeof object !== \"object\")\n            return \"Could not find object with given id\";\n        var entries = InjectedScriptHost.collectionEntries(object);\n        if (!entries)\n            return \"Object with given id is not a collection\";\n        var objectGroupName = InjectedScriptHost.idToObjectGroupName(parsedObjectId.id);\n        for (var i = 0; i < entries.length; ++i) {\n            var entry = nullifyObjectProto(entries[i]);\n            if (\"key\" in entry)\n                entry.key = this._wrapObject(entry.key, objectGroupName);\n            entry.value = this._wrapObject(entry.value, objectGroupName);\n            entries[i] = entry;\n        }\n        return entries;\n    },\n\n    /**\n     * @param {!Object} object\n     * @param {boolean=} ownProperties\n     * @param {boolean=} accessorPropertiesOnly\n     * @param {?Array.<string>=} propertyNamesOnly\n     */\n    _propertyDescriptors: function*(object, ownProperties, accessorPropertiesOnly, propertyNamesOnly)\n    {\n        var propertyProcessed = { __proto__: null };\n\n        /**\n         * @param {?Object} o\n         * @param {!Iterable.<string|symbol>|!Array.<string|symbol>} properties\n         */\n        function* process(o, properties)\n        {\n            for (var property of properties) {\n                if (propertyProcessed[property])\n                    continue;\n\n                var name = property;\n                if (isSymbol(property))\n                    name = /** @type {string} */ (injectedScript._describe(property));\n\n                try {\n                    propertyProcessed[property] = true;\n                    var descriptor = nullifyObjectProto(InjectedScriptHost.suppressWarningsAndCallFunction(Object.getOwnPropertyDescriptor, Object, [o, property]));\n                    if (descriptor) {\n                        if (accessorPropertiesOnly && !(\"get\" in descriptor || \"set\" in descriptor))\n                            continue;\n                        if (\"get\" in descriptor && \"set\" in descriptor && name != \"__proto__\" && InjectedScriptHost.isDOMWrapper(object) && !doesAttributeHaveObservableSideEffectOnGet(object, name)) {\n                            descriptor.value = InjectedScriptHost.suppressWarningsAndCallFunction(function(attribute) { return this[attribute]; }, object, [name]);\n                            delete descriptor.get;\n                            delete descriptor.set;\n                        }\n                    } else {\n                        // Not all bindings provide proper descriptors. Fall back to the writable, configurable property.\n                        if (accessorPropertiesOnly)\n                            continue;\n                        try {\n                            descriptor = { name: name, value: o[property], writable: false, configurable: false, enumerable: false, __proto__: null };\n                            if (o === object)\n                                descriptor.isOwn = true;\n                            yield descriptor;\n                        } catch (e) {\n                            // Silent catch.\n                        }\n                        continue;\n                    }\n                } catch (e) {\n                    if (accessorPropertiesOnly)\n                        continue;\n                    var descriptor = { __proto__: null };\n                    descriptor.value = e;\n                    descriptor.wasThrown = true;\n                }\n\n                descriptor.name = name;\n                if (o === object)\n                    descriptor.isOwn = true;\n                if (isSymbol(property))\n                    descriptor.symbol = property;\n                yield descriptor;\n            }\n        }\n\n        /**\n         * @param {number} length\n         */\n        function* arrayIndexNames(length)\n        {\n            for (var i = 0; i < length; ++i)\n                yield \"\" + i;\n        }\n\n        if (propertyNamesOnly) {\n            for (var i = 0; i < propertyNamesOnly.length; ++i) {\n                var name = propertyNamesOnly[i];\n                for (var o = object; this._isDefined(o); o = o.__proto__) {\n                    if (InjectedScriptHost.suppressWarningsAndCallFunction(Object.prototype.hasOwnProperty, o, [name])) {\n                        for (var descriptor of process(o, [name]))\n                            yield descriptor;\n                        break;\n                    }\n                    if (ownProperties)\n                        break;\n                }\n            }\n            return;\n        }\n\n        var skipGetOwnPropertyNames;\n        try {\n            skipGetOwnPropertyNames = InjectedScriptHost.isTypedArray(object) && object.length > 500000;\n        } catch (e) {\n        }\n\n        for (var o = object; this._isDefined(o); o = o.__proto__) {\n            if (skipGetOwnPropertyNames && o === object) {\n                // Avoid OOM crashes from getting all own property names of a large TypedArray.\n                for (var descriptor of process(o, arrayIndexNames(o.length)))\n                    yield descriptor;\n            } else {\n                // First call Object.keys() to enforce ordering of the property descriptors.\n                for (var descriptor of process(o, Object.keys(/** @type {!Object} */ (o))))\n                    yield descriptor;\n                for (var descriptor of process(o, Object.getOwnPropertyNames(/** @type {!Object} */ (o))))\n                    yield descriptor;\n            }\n            if (Object.getOwnPropertySymbols) {\n                for (var descriptor of process(o, Object.getOwnPropertySymbols(/** @type {!Object} */ (o))))\n                    yield descriptor;\n            }\n            if (ownProperties) {\n                if (object.__proto__ && !accessorPropertiesOnly)\n                    yield { name: \"__proto__\", value: object.__proto__, writable: true, configurable: true, enumerable: false, isOwn: true, __proto__: null };\n                break;\n            }\n        }\n    },\n\n    /**\n     * @param {string} expression\n     * @param {string} objectGroup\n     * @param {boolean} injectCommandLineAPI\n     * @param {boolean} returnByValue\n     * @param {boolean} generatePreview\n     * @return {*}\n     */\n    evaluate: function(expression, objectGroup, injectCommandLineAPI, returnByValue, generatePreview)\n    {\n        return this._evaluateAndWrap(null, expression, objectGroup, injectCommandLineAPI, returnByValue, generatePreview);\n    },\n\n    /**\n     * @param {string} objectId\n     * @param {string} expression\n     * @param {string} args\n     * @param {boolean} returnByValue\n     * @return {!Object|string}\n     */\n    callFunctionOn: function(objectId, expression, args, returnByValue)\n    {\n        var parsedObjectId = this._parseObjectId(objectId);\n        var object = this._objectForId(parsedObjectId);\n        if (!this._isDefined(object))\n            return \"Could not find object with given id\";\n\n        if (args) {\n            var resolvedArgs = [];\n            var callArgs = /** @type {!Array.<!RuntimeAgent.CallArgument>} */ (InjectedScriptHost.eval(args));\n            for (var i = 0; i < callArgs.length; ++i) {\n                try {\n                    resolvedArgs[i] = this._resolveCallArgument(callArgs[i]);\n                } catch (e) {\n                    return toString(e);\n                }\n            }\n        }\n\n        var objectGroup = InjectedScriptHost.idToObjectGroupName(parsedObjectId.id);\n\n        /**\n         * @suppressReceiverCheck\n         * @param {*} object\n         * @param {boolean=} forceValueType\n         * @param {boolean=} generatePreview\n         * @param {?Array.<string>=} columnNames\n         * @param {boolean=} isTable\n         * @param {*=} customObjectConfig\n         * @return {!RuntimeAgent.RemoteObject}\n         * @this {InjectedScript}\n         */\n        function wrap(object, forceValueType, generatePreview, columnNames, isTable, customObjectConfig)\n        {\n            return this._wrapObject(object, objectGroup, forceValueType, generatePreview, columnNames, isTable, false, customObjectConfig);\n        }\n\n        try {\n\n            var remoteObjectAPI = { bindRemoteObject: bind(wrap, this), __proto__: null};\n            InjectedScriptHost.setNonEnumProperty(inspectedGlobalObject, \"__remoteObjectAPI\", remoteObjectAPI);\n\n            var func = InjectedScriptHost.eval(\"with (typeof __remoteObjectAPI !== 'undefined' ? __remoteObjectAPI : { __proto__: null }) {(\" + expression + \")}\");\n            if (typeof func !== \"function\")\n                return \"Given expression does not evaluate to a function\";\n\n            return { wasThrown: false,\n                     result: this._wrapObject(InjectedScriptHost.callFunction(func, object, resolvedArgs), objectGroup, returnByValue),\n                     __proto__: null };\n        } catch (e) {\n            return this._createThrownValue(e, objectGroup, false);\n        } finally {\n            try {\n                delete inspectedGlobalObject[\"__remoteObjectAPI\"];\n            } catch(e) {\n            }\n        }\n    },\n\n    /**\n     * @param {string|undefined} objectGroupName\n     * @param {*} jsonMLObject\n     * @throws {string} error message\n     */\n    _substituteObjectTagsInCustomPreview: function(objectGroupName, jsonMLObject)\n    {\n        var maxCustomPreviewRecursionDepth = 20;\n        this._customPreviewRecursionDepth = (this._customPreviewRecursionDepth || 0) + 1\n        try {\n            if (this._customPreviewRecursionDepth >= maxCustomPreviewRecursionDepth)\n                throw new Error(\"Too deep hierarchy of inlined custom previews\");\n\n            if (!isArrayLike(jsonMLObject))\n                return;\n\n            if (jsonMLObject[0] === \"object\") {\n                var attributes = jsonMLObject[1];\n                var originObject = attributes[\"object\"];\n                var config = attributes[\"config\"];\n                if (typeof originObject === \"undefined\")\n                    throw new Error(\"Illegal format: obligatory attribute \\\"object\\\" isn't specified\");\n\n                jsonMLObject[1] = this._wrapObject(originObject, objectGroupName, false, false, null, false, false, config);\n                return;\n            }\n\n            for (var i = 0; i < jsonMLObject.length; ++i)\n                this._substituteObjectTagsInCustomPreview(objectGroupName, jsonMLObject[i]);\n        } finally {\n            this._customPreviewRecursionDepth--;\n        }\n    },\n\n    /**\n     * Resolves a value from CallArgument description.\n     * @param {!RuntimeAgent.CallArgument} callArgumentJson\n     * @return {*} resolved value\n     * @throws {string} error message\n     */\n    _resolveCallArgument: function(callArgumentJson)\n    {\n        callArgumentJson = nullifyObjectProto(callArgumentJson);\n        var objectId = callArgumentJson.objectId;\n        if (objectId) {\n            var parsedArgId = this._parseObjectId(objectId);\n            if (!parsedArgId || parsedArgId[\"injectedScriptId\"] !== injectedScriptId)\n                throw \"Arguments should belong to the same JavaScript world as the target object.\";\n\n            var resolvedArg = this._objectForId(parsedArgId);\n            if (!this._isDefined(resolvedArg))\n                throw \"Could not find object with given id\";\n\n            return resolvedArg;\n        } else if (\"value\" in callArgumentJson) {\n            var value = callArgumentJson.value;\n            if (callArgumentJson.type === \"number\" && typeof value !== \"number\")\n                value = Number(value);\n            return value;\n        }\n        return undefined;\n    },\n\n    /**\n     * @param {?JavaScriptCallFrame} callFrame\n     * @param {string} expression\n     * @param {string} objectGroup\n     * @param {boolean} injectCommandLineAPI\n     * @param {boolean} returnByValue\n     * @param {boolean} generatePreview\n     * @param {!Array.<!Object>=} scopeChain\n     * @return {!Object}\n     */\n    _evaluateAndWrap: function(callFrame, expression, objectGroup, injectCommandLineAPI, returnByValue, generatePreview, scopeChain)\n    {\n        var wrappedResult = this._evaluateOn(callFrame, objectGroup, expression, injectCommandLineAPI, scopeChain);\n        if (!wrappedResult.exceptionDetails) {\n            return { wasThrown: false,\n                     result: this._wrapObject(wrappedResult.result, objectGroup, returnByValue, generatePreview),\n                     __proto__: null };\n        }\n        return this._createThrownValue(wrappedResult.result, objectGroup, generatePreview, wrappedResult.exceptionDetails);\n    },\n\n    /**\n     * @param {*} value\n     * @param {string|undefined} objectGroup\n     * @param {boolean} generatePreview\n     * @param {!DebuggerAgent.ExceptionDetails=} exceptionDetails\n     * @return {!Object}\n     */\n    _createThrownValue: function(value, objectGroup, generatePreview, exceptionDetails)\n    {\n        var remoteObject = this._wrapObject(value, objectGroup, false, generatePreview && InjectedScriptHost.subtype(value) !== \"error\");\n        if (!remoteObject.description){\n            try {\n                remoteObject.description = toStringDescription(value);\n            } catch (e) {}\n        }\n        return { wasThrown: true, result: remoteObject, exceptionDetails: exceptionDetails, __proto__: null };\n    },\n\n    /**\n     * @param {?JavaScriptCallFrame} callFrame\n     * @param {string} objectGroup\n     * @param {string} expression\n     * @param {boolean} injectCommandLineAPI\n     * @param {!Array.<!Object>=} scopeChain\n     * @return {*}\n     */\n    _evaluateOn: function(callFrame, objectGroup, expression, injectCommandLineAPI, scopeChain)\n    {\n        // Only install command line api object for the time of evaluation.\n        // Surround the expression in with statements to inject our command line API so that\n        // the window object properties still take more precedent than our API functions.\n\n        var scopeExtensionForEval = (callFrame && injectCommandLineAPI) ? new CommandLineAPI(this._commandLineAPIImpl, callFrame) : undefined;\n\n        injectCommandLineAPI = !scopeExtensionForEval && !callFrame && injectCommandLineAPI && !(\"__commandLineAPI\" in inspectedGlobalObject);\n        var injectScopeChain = scopeChain && scopeChain.length && !(\"__scopeChainForEval\" in inspectedGlobalObject);\n\n        try {\n            var prefix = \"\";\n            var suffix = \"\";\n            if (injectCommandLineAPI) {\n                InjectedScriptHost.setNonEnumProperty(inspectedGlobalObject, \"__commandLineAPI\", new CommandLineAPI(this._commandLineAPIImpl, callFrame));\n                prefix = \"with (typeof __commandLineAPI !== 'undefined' ? __commandLineAPI : { __proto__: null }) {\";\n                suffix = \"}\";\n            }\n            if (injectScopeChain) {\n                InjectedScriptHost.setNonEnumProperty(inspectedGlobalObject, \"__scopeChainForEval\", scopeChain);\n                for (var i = 0; i < scopeChain.length; ++i) {\n                    prefix = \"with (typeof __scopeChainForEval !== 'undefined' ? __scopeChainForEval[\" + i + \"] : { __proto__: null }) {\" + (suffix ? \" \" : \"\") + prefix;\n                    if (suffix)\n                        suffix += \" }\";\n                    else\n                        suffix = \"}\";\n                }\n            }\n\n            if (prefix)\n                expression = prefix + \"\\n\" + expression + \"\\n\" + suffix;\n            var wrappedResult = callFrame ? callFrame.evaluateWithExceptionDetails(expression, scopeExtensionForEval) : InjectedScriptHost.evaluateWithExceptionDetails(expression);\n            if (objectGroup === \"console\" && !wrappedResult.exceptionDetails)\n                this._lastResult = wrappedResult.result;\n            return wrappedResult;\n        } finally {\n            if (injectCommandLineAPI) {\n                try {\n                    delete inspectedGlobalObject[\"__commandLineAPI\"];\n                } catch(e) {\n                }\n            }\n            if (injectScopeChain) {\n                try {\n                    delete inspectedGlobalObject[\"__scopeChainForEval\"];\n                } catch(e) {\n                }\n            }\n        }\n    },\n\n    /**\n     * @param {?Object} callFrame\n     * @param {number} asyncOrdinal\n     * @return {!Array.<!InjectedScript.CallFrameProxy>|boolean}\n     */\n    wrapCallFrames: function(callFrame, asyncOrdinal)\n    {\n        if (!callFrame)\n            return false;\n\n        var result = [];\n        var depth = 0;\n        do {\n            result[depth] = new InjectedScript.CallFrameProxy(depth, callFrame, asyncOrdinal);\n            callFrame = callFrame.caller;\n            ++depth;\n        } while (callFrame);\n        return result;\n    },\n\n    /**\n     * @param {!JavaScriptCallFrame} topCallFrame\n     * @param {boolean} isAsyncStack\n     * @param {string} callFrameId\n     * @param {string} expression\n     * @param {string} objectGroup\n     * @param {boolean} injectCommandLineAPI\n     * @param {boolean} returnByValue\n     * @param {boolean} generatePreview\n     * @return {*}\n     */\n    evaluateOnCallFrame: function(topCallFrame, isAsyncStack, callFrameId, expression, objectGroup, injectCommandLineAPI, returnByValue, generatePreview)\n    {\n        var callFrame = this._callFrameForId(topCallFrame, callFrameId);\n        if (!callFrame)\n            return \"Could not find call frame with given id\";\n        if (isAsyncStack)\n            return this._evaluateAndWrap(null, expression, objectGroup, injectCommandLineAPI, returnByValue, generatePreview, callFrame.scopeChain);\n        return this._evaluateAndWrap(callFrame, expression, objectGroup, injectCommandLineAPI, returnByValue, generatePreview);\n    },\n\n    /**\n     * @param {!JavaScriptCallFrame} topCallFrame\n     * @param {string} callFrameId\n     * @return {*}\n     */\n    restartFrame: function(topCallFrame, callFrameId)\n    {\n        var callFrame = this._callFrameForId(topCallFrame, callFrameId);\n        if (!callFrame)\n            return \"Could not find call frame with given id\";\n        return callFrame.restart();\n    },\n\n    /**\n     * @param {!JavaScriptCallFrame} topCallFrame\n     * @param {string} callFrameId\n     * @return {*} a stepIn position array ready for protocol JSON or a string error\n     */\n    getStepInPositions: function(topCallFrame, callFrameId)\n    {\n        var callFrame = this._callFrameForId(topCallFrame, callFrameId);\n        if (!callFrame)\n            return \"Could not find call frame with given id\";\n        var stepInPositionsUnpacked = JSON.parse(callFrame.stepInPositions);\n        if (typeof stepInPositionsUnpacked !== \"object\")\n            return \"Step in positions not available\";\n        return stepInPositionsUnpacked;\n    },\n\n    /**\n     * Either callFrameId or functionObjectId must be specified.\n     * @param {!JavaScriptCallFrame} topCallFrame\n     * @param {string|boolean} callFrameId or false\n     * @param {string|boolean} functionObjectId or false\n     * @param {number} scopeNumber\n     * @param {string} variableName\n     * @param {string} newValueJsonString RuntimeAgent.CallArgument structure serialized as string\n     * @return {string|undefined} undefined if success or an error message\n     */\n    setVariableValue: function(topCallFrame, callFrameId, functionObjectId, scopeNumber, variableName, newValueJsonString)\n    {\n        try {\n            var newValueJson = /** @type {!RuntimeAgent.CallArgument} */ (InjectedScriptHost.eval(\"(\" + newValueJsonString + \")\"));\n            var resolvedValue = this._resolveCallArgument(newValueJson);\n            if (typeof callFrameId === \"string\") {\n                var callFrame = this._callFrameForId(topCallFrame, callFrameId);\n                if (!callFrame)\n                    return \"Could not find call frame with given id\";\n                callFrame.setVariableValue(scopeNumber, variableName, resolvedValue)\n            } else {\n                var parsedFunctionId = this._parseObjectId(/** @type {string} */ (functionObjectId));\n                var func = this._objectForId(parsedFunctionId);\n                if (typeof func !== \"function\")\n                    return \"Could not resolve function by id\";\n                InjectedScriptHost.setFunctionVariableValue(func, scopeNumber, variableName, resolvedValue);\n            }\n        } catch (e) {\n            return toString(e);\n        }\n        return undefined;\n    },\n\n    /**\n     * @param {!JavaScriptCallFrame} topCallFrame\n     * @param {string} callFrameId\n     * @return {?JavaScriptCallFrame}\n     */\n    _callFrameForId: function(topCallFrame, callFrameId)\n    {\n        var parsedCallFrameId = nullifyObjectProto(/** @type {!Object} */ (InjectedScriptHost.eval(\"(\" + callFrameId + \")\")));\n        var ordinal = parsedCallFrameId[\"ordinal\"];\n        var callFrame = topCallFrame;\n        while (--ordinal >= 0 && callFrame)\n            callFrame = callFrame.caller;\n        return callFrame;\n    },\n\n    /**\n     * @param {!Object} objectId\n     * @return {!Object|symbol|undefined}\n     */\n    _objectForId: function(objectId)\n    {\n        return objectId.injectedScriptId === injectedScriptId ? /** @type{!Object|symbol|undefined} */ (InjectedScriptHost.objectForId(objectId.id)) : void 0;\n    },\n\n    /**\n     * @param {*} object\n     * @return {boolean}\n     */\n    _isDefined: function(object)\n    {\n        return !!object || this._isHTMLAllCollection(object);\n    },\n\n    /**\n     * @param {*} object\n     * @return {boolean}\n     */\n    _isHTMLAllCollection: function(object)\n    {\n        // document.all is reported as undefined, but we still want to process it.\n        return (typeof object === \"undefined\") && InjectedScriptHost.isHTMLAllCollection(object);\n    },\n\n    /**\n     * @param {*} obj\n     * @return {?string}\n     */\n    _subtype: function(obj)\n    {\n        if (obj === null)\n            return \"null\";\n\n        if (this.isPrimitiveValue(obj))\n            return null;\n\n        var subtype = InjectedScriptHost.subtype(obj);\n        if (subtype)\n            return subtype;\n\n        if (isArrayLike(obj))\n            return \"array\";\n\n        // If owning frame has navigated to somewhere else window properties will be undefined.\n        return null;\n    },\n\n    /**\n     * @param {*} obj\n     * @return {?string}\n     */\n    _describe: function(obj)\n    {\n        if (this.isPrimitiveValue(obj))\n            return null;\n\n        var subtype = this._subtype(obj);\n\n        if (subtype === \"regexp\")\n            return toString(obj);\n\n        if (subtype === \"date\")\n            return toString(obj);\n\n        if (subtype === \"node\") {\n            var description = obj.nodeName.toLowerCase();\n            switch (obj.nodeType) {\n            case 1 /* Node.ELEMENT_NODE */:\n                description += obj.id ? \"#\" + obj.id : \"\";\n                var className = obj.className;\n                description += (className && typeof className === \"string\") ? \".\" + className.trim().replace(/\\s+/g, \".\") : \"\";\n                break;\n            case 10 /*Node.DOCUMENT_TYPE_NODE */:\n                description = \"<!DOCTYPE \" + description + \">\";\n                break;\n            }\n            return description;\n        }\n\n        var className = InjectedScriptHost.internalConstructorName(obj);\n        if (subtype === \"array\") {\n            if (typeof obj.length === \"number\")\n                className += \"[\" + obj.length + \"]\";\n            return className;\n        }\n\n        // NodeList in JSC is a function, check for array prior to this.\n        if (typeof obj === \"function\")\n            return toString(obj);\n\n        if (isSymbol(obj)) {\n            try {\n                return /** @type {string} */ (InjectedScriptHost.callFunction(Symbol.prototype.toString, obj)) || \"Symbol\";\n            } catch (e) {\n                return \"Symbol\";\n            }\n        }\n\n        if (InjectedScriptHost.subtype(obj) === \"error\") {\n            try {\n                var stack = obj.stack;\n                var message = obj.message && obj.message.length ? \": \" + obj.message : \"\";\n                var firstCallFrame = /^\\s+at\\s/m.exec(stack);\n                var stackMessageEnd = firstCallFrame ? firstCallFrame.index : -1;\n                if (stackMessageEnd !== -1) {\n                    var stackTrace = stack.substr(stackMessageEnd);\n                    return className + message + \"\\n\" + stackTrace;\n                }\n                return className + message;\n            } catch(e) {\n            }\n        }\n\n        return className;\n    },\n\n    /**\n     * @param {boolean} enabled\n     */\n    setCustomObjectFormatterEnabled: function(enabled)\n    {\n        this._customObjectFormatterEnabled = enabled;\n    }\n}\n\n/**\n * @type {!InjectedScript}\n * @const\n */\nvar injectedScript = new InjectedScript();\n\n/**\n * @constructor\n * @param {*} object\n * @param {string=} objectGroupName\n * @param {boolean=} doNotBind\n * @param {boolean=} forceValueType\n * @param {boolean=} generatePreview\n * @param {?Array.<string>=} columnNames\n * @param {boolean=} isTable\n * @param {boolean=} skipEntriesPreview\n * @param {*=} customObjectConfig\n */\nInjectedScript.RemoteObject = function(object, objectGroupName, doNotBind, forceValueType, generatePreview, columnNames, isTable, skipEntriesPreview, customObjectConfig)\n{\n    this.type = typeof object;\n    if (this.type === \"undefined\" && injectedScript._isHTMLAllCollection(object))\n        this.type = \"object\";\n\n    if (injectedScript.isPrimitiveValue(object) || object === null || forceValueType) {\n        // We don't send undefined values over JSON.\n        if (this.type !== \"undefined\")\n            this.value = object;\n\n        // Null object is object with 'null' subtype.\n        if (object === null)\n            this.subtype = \"null\";\n\n        // Provide user-friendly number values.\n        if (this.type === \"number\") {\n            this.description = toStringDescription(object);\n            // Override \"value\" property for values that can not be JSON-stringified.\n            switch (this.description) {\n            case \"NaN\":\n            case \"Infinity\":\n            case \"-Infinity\":\n            case \"-0\":\n                this.value = this.description;\n                break;\n            }\n        }\n\n        return;\n    }\n\n    object = /** @type {!Object} */ (object);\n\n    if (!doNotBind)\n        this.objectId = injectedScript._bind(object, objectGroupName);\n    var subtype = injectedScript._subtype(object);\n    if (subtype)\n        this.subtype = subtype;\n    var className = InjectedScriptHost.internalConstructorName(object);\n    if (className)\n        this.className = className;\n    this.description = injectedScript._describe(object);\n\n    if (generatePreview && this.type === \"object\" && this.subtype !== \"node\")\n        this.preview = this._generatePreview(object, undefined, columnNames, isTable, skipEntriesPreview);\n\n    if (injectedScript._customObjectFormatterEnabled) {\n        var customPreview = this._customPreview(object, objectGroupName, customObjectConfig);\n        if (customPreview)\n            this.customPreview = customPreview;\n    }\n}\n\nInjectedScript.RemoteObject.prototype = {\n\n    /**\n     * @param {*} object\n     * @param {string=} objectGroupName\n     * @param {*=} customObjectConfig\n     * @return {?RuntimeAgent.CustomPreview}\n     */\n    _customPreview: function(object, objectGroupName, customObjectConfig)\n    {\n        /**\n         * @param {!Error} error\n         */\n        function logError(error)\n        {\n            Promise.resolve().then(inspectedGlobalObject.console.error.bind(inspectedGlobalObject.console, \"Custom Formatter Failed: \" + error.message));\n        }\n\n        try {\n            var formatters = inspectedGlobalObject[\"devtoolsFormatters\"];\n            if (!formatters || !isArrayLike(formatters))\n                return null;\n\n            for (var i = 0; i < formatters.length; ++i) {\n                try {\n                    var formatted = formatters[i].header(object, customObjectConfig);\n                    if (!formatted)\n                        continue;\n\n                    var hasBody = formatters[i].hasBody(object, customObjectConfig);\n                    injectedScript._substituteObjectTagsInCustomPreview(objectGroupName, formatted);\n                    var formatterObjectId = injectedScript._bind(formatters[i], objectGroupName);\n                    var result = {header: JSON.stringify(formatted), hasBody: !!hasBody, formatterObjectId: formatterObjectId};\n                    if (customObjectConfig)\n                        result[\"configObjectId\"] = injectedScript._bind(customObjectConfig, objectGroupName);\n                    return result;\n                } catch (e) {\n                    logError(e);\n                }\n            }\n        } catch (e) {\n            logError(e);\n        }\n        return null;\n    },\n\n    /**\n     * @return {!RuntimeAgent.ObjectPreview} preview\n     */\n    _createEmptyPreview: function()\n    {\n        var preview = {\n            type: /** @type {!RuntimeAgent.ObjectPreviewType.<string>} */ (this.type),\n            description: this.description || toStringDescription(this.value),\n            lossless: true,\n            overflow: false,\n            properties: [],\n            __proto__: null\n        };\n        if (this.subtype)\n            preview.subtype = /** @type {!RuntimeAgent.ObjectPreviewSubtype.<string>} */ (this.subtype);\n        return preview;\n    },\n\n    /**\n     * @param {!Object} object\n     * @param {?Array.<string>=} firstLevelKeys\n     * @param {?Array.<string>=} secondLevelKeys\n     * @param {boolean=} isTable\n     * @param {boolean=} skipEntriesPreview\n     * @return {!RuntimeAgent.ObjectPreview} preview\n     */\n    _generatePreview: function(object, firstLevelKeys, secondLevelKeys, isTable, skipEntriesPreview)\n    {\n        var preview = this._createEmptyPreview();\n        var firstLevelKeysCount = firstLevelKeys ? firstLevelKeys.length : 0;\n\n        var propertiesThreshold = {\n            properties: isTable ? 1000 : max(5, firstLevelKeysCount),\n            indexes: isTable ? 1000 : max(100, firstLevelKeysCount),\n            __proto__: null\n        };\n\n        try {\n            var descriptors = injectedScript._propertyDescriptors(object, undefined, undefined, firstLevelKeys);\n\n            this._appendPropertyDescriptors(preview, descriptors, propertiesThreshold, secondLevelKeys, isTable);\n            if (propertiesThreshold.indexes < 0 || propertiesThreshold.properties < 0)\n                return preview;\n\n            // Add internal properties to preview.\n            var rawInternalProperties = InjectedScriptHost.getInternalProperties(object) || [];\n            var internalProperties = [];\n            for (var i = 0; i < rawInternalProperties.length; i += 2) {\n                push(internalProperties, {\n                    name: rawInternalProperties[i],\n                    value: rawInternalProperties[i + 1],\n                    isOwn: true,\n                    enumerable: true,\n                    __proto__: null\n                });\n            }\n            this._appendPropertyDescriptors(preview, internalProperties, propertiesThreshold, secondLevelKeys, isTable);\n\n            if (this.subtype === \"map\" || this.subtype === \"set\" || this.subtype === \"iterator\")\n                this._appendEntriesPreview(object, preview, skipEntriesPreview);\n\n        } catch (e) {\n            preview.lossless = false;\n        }\n\n        return preview;\n    },\n\n    /**\n     * @param {!RuntimeAgent.ObjectPreview} preview\n     * @param {!Array.<*>|!Iterable.<*>} descriptors\n     * @param {!Object} propertiesThreshold\n     * @param {?Array.<string>=} secondLevelKeys\n     * @param {boolean=} isTable\n     */\n    _appendPropertyDescriptors: function(preview, descriptors, propertiesThreshold, secondLevelKeys, isTable)\n    {\n        for (var descriptor of descriptors) {\n            if (propertiesThreshold.indexes < 0 || propertiesThreshold.properties < 0)\n                break;\n            if (!descriptor)\n                continue;\n            if (descriptor.wasThrown) {\n                preview.lossless = false;\n                continue;\n            }\n\n            var name = descriptor.name;\n\n            // Ignore __proto__ property, stay lossless.\n            if (name === \"__proto__\")\n                continue;\n\n            // Ignore non-enumerable members on prototype, stay lossless.\n            if (!descriptor.isOwn && !descriptor.enumerable)\n                continue;\n\n            // Ignore length property of array, stay lossless.\n            if (this.subtype === \"array\" && name === \"length\")\n                continue;\n\n            // Ignore size property of map, set, stay lossless.\n            if ((this.subtype === \"map\" || this.subtype === \"set\") && name === \"size\")\n                continue;\n\n            // Never preview prototype properties, turn lossy.\n            if (!descriptor.isOwn) {\n                preview.lossless = false;\n                continue;\n            }\n\n            // Ignore computed properties, turn lossy.\n            if (!(\"value\" in descriptor)) {\n                preview.lossless = false;\n                continue;\n            }\n\n            var value = descriptor.value;\n            var type = typeof value;\n\n            // Never render functions in object preview, turn lossy\n            if (type === \"function\" && (this.subtype !== \"array\" || !isUInt32(name))) {\n                preview.lossless = false;\n                continue;\n            }\n\n            // Special-case HTMLAll.\n            if (type === \"undefined\" && injectedScript._isHTMLAllCollection(value))\n                type = \"object\";\n\n            // Render own properties.\n            if (value === null) {\n                this._appendPropertyPreview(preview, { name: name, type: \"object\", subtype: \"null\", value: \"null\", __proto__: null }, propertiesThreshold);\n                continue;\n            }\n\n            var maxLength = 100;\n            if (InjectedScript.primitiveTypes[type]) {\n                if (type === \"string\" && value.length > maxLength) {\n                    value = this._abbreviateString(value, maxLength, true);\n                    preview.lossless = false;\n                }\n                this._appendPropertyPreview(preview, { name: name, type: type, value: toStringDescription(value), __proto__: null }, propertiesThreshold);\n                continue;\n            }\n\n            var property = { name: name, type: type, __proto__: null };\n            var subtype = injectedScript._subtype(value);\n            if (subtype)\n                property.subtype = subtype;\n\n            if (secondLevelKeys === null || secondLevelKeys) {\n                var subPreview = this._generatePreview(value, secondLevelKeys || undefined, undefined, isTable);\n                property.valuePreview = subPreview;\n                if (!subPreview.lossless)\n                    preview.lossless = false;\n                if (subPreview.overflow)\n                    preview.overflow = true;\n            } else {\n                var description = \"\";\n                if (type !== \"function\")\n                    description = this._abbreviateString(/** @type {string} */ (injectedScript._describe(value)), maxLength, subtype === \"regexp\");\n                property.value = description;\n                preview.lossless = false;\n            }\n            this._appendPropertyPreview(preview, property, propertiesThreshold);\n        }\n    },\n\n    /**\n     * @param {!RuntimeAgent.ObjectPreview} preview\n     * @param {!Object} property\n     * @param {!Object} propertiesThreshold\n     */\n    _appendPropertyPreview: function(preview, property, propertiesThreshold)\n    {\n        if (toString(property.name >>> 0) === property.name)\n            propertiesThreshold.indexes--;\n        else\n            propertiesThreshold.properties--;\n        if (propertiesThreshold.indexes < 0 || propertiesThreshold.properties < 0) {\n            preview.overflow = true;\n            preview.lossless = false;\n        } else {\n            push(preview.properties, property);\n        }\n    },\n\n    /**\n     * @param {!Object} object\n     * @param {!RuntimeAgent.ObjectPreview} preview\n     * @param {boolean=} skipEntriesPreview\n     */\n    _appendEntriesPreview: function(object, preview, skipEntriesPreview)\n    {\n        var entries = InjectedScriptHost.collectionEntries(object);\n        if (!entries)\n            return;\n        if (skipEntriesPreview) {\n            if (entries.length) {\n                preview.overflow = true;\n                preview.lossless = false;\n            }\n            return;\n        }\n        preview.entries = [];\n        var entriesThreshold = 5;\n        for (var i = 0; i < entries.length; ++i) {\n            if (preview.entries.length >= entriesThreshold) {\n                preview.overflow = true;\n                preview.lossless = false;\n                break;\n            }\n            var entry = nullifyObjectProto(entries[i]);\n            var previewEntry = {\n                value: generateValuePreview(entry.value),\n                __proto__: null\n            };\n            if (\"key\" in entry)\n                previewEntry.key = generateValuePreview(entry.key);\n            push(preview.entries, previewEntry);\n        }\n\n        /**\n         * @param {*} value\n         * @return {!RuntimeAgent.ObjectPreview}\n         */\n        function generateValuePreview(value)\n        {\n            var remoteObject = new InjectedScript.RemoteObject(value, undefined, true, undefined, true, undefined, undefined, true);\n            var valuePreview = remoteObject.preview || remoteObject._createEmptyPreview();\n            if (!valuePreview.lossless)\n                preview.lossless = false;\n            return valuePreview;\n        }\n    },\n\n    /**\n     * @param {string} string\n     * @param {number} maxLength\n     * @param {boolean=} middle\n     * @return {string}\n     */\n    _abbreviateString: function(string, maxLength, middle)\n    {\n        if (string.length <= maxLength)\n            return string;\n        if (middle) {\n            var leftHalf = maxLength >> 1;\n            var rightHalf = maxLength - leftHalf - 1;\n            return string.substr(0, leftHalf) + \"\\u2026\" + string.substr(string.length - rightHalf, rightHalf);\n        }\n        return string.substr(0, maxLength) + \"\\u2026\";\n    },\n\n    __proto__: null\n}\n\n/**\n * @constructor\n * @param {number} ordinal\n * @param {!JavaScriptCallFrame} callFrame\n * @param {number} asyncOrdinal\n */\nInjectedScript.CallFrameProxy = function(ordinal, callFrame, asyncOrdinal)\n{\n    this.callFrameId = \"{\\\"ordinal\\\":\" + ordinal + \",\\\"injectedScriptId\\\":\" + injectedScriptId + (asyncOrdinal ? \",\\\"asyncOrdinal\\\":\" + asyncOrdinal : \"\") + \"}\";\n    this.functionName = callFrame.functionName;\n    this.functionLocation = { scriptId: toString(callFrame.sourceID), lineNumber: callFrame.functionLine, columnNumber: callFrame.functionColumn, __proto__: null };\n    this.location = { scriptId: toString(callFrame.sourceID), lineNumber: callFrame.line, columnNumber: callFrame.column, __proto__: null };\n    this.scopeChain = this._wrapScopeChain(callFrame);\n    this.this = injectedScript._wrapObject(callFrame.thisObject, \"backtrace\");\n    if (callFrame.isAtReturn)\n        this.returnValue = injectedScript._wrapObject(callFrame.returnValue, \"backtrace\");\n}\n\nInjectedScript.CallFrameProxy.prototype = {\n    /**\n     * @param {!JavaScriptCallFrame} callFrame\n     * @return {!Array.<!DebuggerAgent.Scope>}\n     */\n    _wrapScopeChain: function(callFrame)\n    {\n        var scopeChain = callFrame.scopeChain;\n        var scopeChainProxy = [];\n        for (var i = 0; i < scopeChain.length; ++i)\n            scopeChainProxy[i] = InjectedScript.CallFrameProxy._createScopeJson(callFrame.scopeType(i), scopeChain[i], \"backtrace\");\n        return scopeChainProxy;\n    },\n\n    __proto__: null\n}\n\n/**\n * @const\n * @type {!Object.<number, !DebuggerAgent.ScopeType>}\n */\nInjectedScript.CallFrameProxy._scopeTypeNames = {\n    0: \"global\",\n    1: \"local\",\n    2: \"with\",\n    3: \"closure\",\n    4: \"catch\",\n    5: \"block\",\n    6: \"script\",\n    __proto__: null\n};\n\n/**\n * @param {number} scopeTypeCode\n * @param {*} scopeObject\n * @param {string} groupId\n * @return {!DebuggerAgent.Scope}\n */\nInjectedScript.CallFrameProxy._createScopeJson = function(scopeTypeCode, scopeObject, groupId)\n{\n    return {\n        object: injectedScript._wrapObject(scopeObject, groupId),\n        type: InjectedScript.CallFrameProxy._scopeTypeNames[scopeTypeCode],\n        __proto__: null\n    };\n}\n\n/**\n * @constructor\n * @param {!CommandLineAPIImpl} commandLineAPIImpl\n * @param {?JavaScriptCallFrame} callFrame\n */\nfunction CommandLineAPI(commandLineAPIImpl, callFrame)\n{\n    /**\n     * @param {string} member\n     * @return {boolean}\n     */\n    function inScopeVariables(member)\n    {\n        if (!callFrame)\n            return (member in inspectedGlobalObject);\n\n        var scopeChain = callFrame.scopeChain;\n        for (var i = 0; i < scopeChain.length; ++i) {\n            if (member in scopeChain[i])\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * @param {string} name The name of the method for which a toString method should be generated.\n     * @return {function():string}\n     */\n    function customToStringMethod(name)\n    {\n        return function()\n        {\n            var funcArgsSyntax = \"\";\n            try {\n                var funcSyntax = \"\" + commandLineAPIImpl[name];\n                funcSyntax = funcSyntax.replace(/\\n/g, \" \");\n                funcSyntax = funcSyntax.replace(/^function[^\\(]*\\(([^\\)]*)\\).*$/, \"$1\");\n                funcSyntax = funcSyntax.replace(/\\s*,\\s*/g, \", \");\n                funcSyntax = funcSyntax.replace(/\\bopt_(\\w+)\\b/g, \"[$1]\");\n                funcArgsSyntax = funcSyntax.trim();\n            } catch (e) {\n            }\n            return \"function \" + name + \"(\" + funcArgsSyntax + \") { [Command Line API] }\";\n        };\n    }\n\n    for (var i = 0; i < CommandLineAPI.members_.length; ++i) {\n        var member = CommandLineAPI.members_[i];\n        if (inScopeVariables(member))\n            continue;\n\n        this[member] = bind(commandLineAPIImpl[member], commandLineAPIImpl);\n        this[member].toString = customToStringMethod(member);\n    }\n\n    for (var i = 0; i < 5; ++i) {\n        var member = \"$\" + i;\n        if (inScopeVariables(member))\n            continue;\n\n        this.__defineGetter__(\"$\" + i, bind(commandLineAPIImpl._inspectedObject, commandLineAPIImpl, i));\n    }\n\n    this.$_ = injectedScript._lastResult;\n\n    this.__proto__ = null;\n}\n\n// NOTE: Please keep the list of API methods below snchronized to that in WebInspector.RuntimeModel!\n// NOTE: Argument names of these methods will be printed in the console, so use pretty names!\n/**\n * @type {!Array.<string>}\n * @const\n */\nCommandLineAPI.members_ = [\n    \"$\", \"$$\", \"$x\", \"dir\", \"dirxml\", \"keys\", \"values\", \"profile\", \"profileEnd\",\n    \"monitorEvents\", \"unmonitorEvents\", \"inspect\", \"copy\", \"clear\", \"getEventListeners\",\n    \"debug\", \"undebug\", \"monitor\", \"unmonitor\", \"table\"\n];\n\n/**\n * @constructor\n */\nfunction CommandLineAPIImpl()\n{\n}\n\nCommandLineAPIImpl.prototype = {\n    /**\n     * @param {string} selector\n     * @param {!Node=} opt_startNode\n     * @return {*}\n     */\n    $: function (selector, opt_startNode)\n    {\n        if (this._canQuerySelectorOnNode(opt_startNode))\n            return opt_startNode.querySelector(selector);\n\n        return inspectedGlobalObject.document.querySelector(selector);\n    },\n\n    /**\n     * @param {string} selector\n     * @param {!Node=} opt_startNode\n     * @return {*}\n     */\n    $$: function (selector, opt_startNode)\n    {\n        if (this._canQuerySelectorOnNode(opt_startNode))\n            return slice(opt_startNode.querySelectorAll(selector));\n        return slice(inspectedGlobalObject.document.querySelectorAll(selector));\n    },\n\n    /**\n     * @param {!Node=} node\n     * @return {boolean}\n     */\n    _canQuerySelectorOnNode: function(node)\n    {\n        return !!node && InjectedScriptHost.subtype(node) === \"node\" && (node.nodeType === Node.ELEMENT_NODE || node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n    },\n\n    /**\n     * @param {string} xpath\n     * @param {!Node=} opt_startNode\n     * @return {*}\n     */\n    $x: function(xpath, opt_startNode)\n    {\n        var doc = (opt_startNode && opt_startNode.ownerDocument) || inspectedGlobalObject.document;\n        var result = doc.evaluate(xpath, opt_startNode || doc, null, XPathResult.ANY_TYPE, null);\n        switch (result.resultType) {\n        case XPathResult.NUMBER_TYPE:\n            return result.numberValue;\n        case XPathResult.STRING_TYPE:\n            return result.stringValue;\n        case XPathResult.BOOLEAN_TYPE:\n            return result.booleanValue;\n        default:\n            var nodes = [];\n            var node;\n            while (node = result.iterateNext())\n                push(nodes, node);\n            return nodes;\n        }\n    },\n\n    /**\n     * @return {*}\n     */\n    dir: function(var_args)\n    {\n        return InjectedScriptHost.callFunction(inspectedGlobalObject.console.dir, inspectedGlobalObject.console, slice(arguments));\n    },\n\n    /**\n     * @return {*}\n     */\n    dirxml: function(var_args)\n    {\n        return InjectedScriptHost.callFunction(inspectedGlobalObject.console.dirxml, inspectedGlobalObject.console, slice(arguments));\n    },\n\n    /**\n     * @return {!Array.<string>}\n     */\n    keys: function(object)\n    {\n        return Object.keys(object);\n    },\n\n    /**\n     * @return {!Array.<*>}\n     */\n    values: function(object)\n    {\n        var result = [];\n        for (var key in object)\n            push(result, object[key]);\n        return result;\n    },\n\n    /**\n     * @return {*}\n     */\n    profile: function(opt_title)\n    {\n        return InjectedScriptHost.callFunction(inspectedGlobalObject.console.profile, inspectedGlobalObject.console, slice(arguments));\n    },\n\n    /**\n     * @return {*}\n     */\n    profileEnd: function(opt_title)\n    {\n        return InjectedScriptHost.callFunction(inspectedGlobalObject.console.profileEnd, inspectedGlobalObject.console, slice(arguments));\n    },\n\n    /**\n     * @param {!Object} object\n     * @param {!Array.<string>|string=} opt_types\n     */\n    monitorEvents: function(object, opt_types)\n    {\n        if (!object || !object.addEventListener || !object.removeEventListener)\n            return;\n        var types = this._normalizeEventTypes(opt_types);\n        for (var i = 0; i < types.length; ++i) {\n            object.removeEventListener(types[i], this._logEvent, false);\n            object.addEventListener(types[i], this._logEvent, false);\n        }\n    },\n\n    /**\n     * @param {!Object} object\n     * @param {!Array.<string>|string=} opt_types\n     */\n    unmonitorEvents: function(object, opt_types)\n    {\n        if (!object || !object.addEventListener || !object.removeEventListener)\n            return;\n        var types = this._normalizeEventTypes(opt_types);\n        for (var i = 0; i < types.length; ++i)\n            object.removeEventListener(types[i], this._logEvent, false);\n    },\n\n    /**\n     * @param {*} object\n     * @return {*}\n     */\n    inspect: function(object)\n    {\n        return injectedScript._inspect(object);\n    },\n\n    copy: function(object)\n    {\n        var string;\n        if (injectedScript._subtype(object) === \"node\") {\n            string = object.outerHTML;\n        } else if (injectedScript.isPrimitiveValue(object)) {\n            string = toString(object);\n        } else {\n            try {\n                string = JSON.stringify(object, null, \"  \");\n            } catch (e) {\n                string = toString(object);\n            }\n        }\n\n        var hints = { copyToClipboard: true, __proto__: null };\n        var remoteObject = injectedScript._wrapObject(string, \"\")\n        InjectedScriptHost.inspect(remoteObject, hints);\n    },\n\n    clear: function()\n    {\n        InjectedScriptHost.clearConsoleMessages();\n    },\n\n    /**\n     * @param {!Node} node\n     * @return {!Array.<!{type: string, listener: function(), useCapture: boolean, remove: function()}>|undefined}\n     */\n    getEventListeners: function(node)\n    {\n        var result = nullifyObjectProto(InjectedScriptHost.getEventListeners(node));\n        if (!result)\n            return result;\n        /** @this {{type: string, listener: function(), useCapture: boolean}} */\n        var removeFunc = function()\n        {\n            node.removeEventListener(this.type, this.listener, this.useCapture);\n        }\n        for (var type in result) {\n            var listeners = result[type];\n            for (var i = 0, listener; listener = listeners[i]; ++i) {\n                listener[\"type\"] = type;\n                listener[\"remove\"] = removeFunc;\n            }\n        }\n        return result;\n    },\n\n    debug: function(fn)\n    {\n        InjectedScriptHost.debugFunction(fn);\n    },\n\n    undebug: function(fn)\n    {\n        InjectedScriptHost.undebugFunction(fn);\n    },\n\n    monitor: function(fn)\n    {\n        InjectedScriptHost.monitorFunction(fn);\n    },\n\n    unmonitor: function(fn)\n    {\n        InjectedScriptHost.unmonitorFunction(fn);\n    },\n\n    table: function(data, opt_columns)\n    {\n        InjectedScriptHost.callFunction(inspectedGlobalObject.console.table, inspectedGlobalObject.console, slice(arguments));\n    },\n\n    /**\n     * @param {number} num\n     */\n    _inspectedObject: function(num)\n    {\n        return InjectedScriptHost.inspectedObject(num);\n    },\n\n    /**\n     * @param {!Array.<string>|string=} types\n     * @return {!Array.<string>}\n     */\n    _normalizeEventTypes: function(types)\n    {\n        if (typeof types === \"undefined\")\n            types = [\"mouse\", \"key\", \"touch\", \"pointer\", \"control\", \"load\", \"unload\", \"abort\", \"error\", \"select\", \"input\", \"change\", \"submit\", \"reset\", \"focus\", \"blur\", \"resize\", \"scroll\", \"search\", \"devicemotion\", \"deviceorientation\"];\n        else if (typeof types === \"string\")\n            types = [types];\n\n        var result = [];\n        for (var i = 0; i < types.length; ++i) {\n            if (types[i] === \"mouse\")\n                push(result, \"click\", \"dblclick\", \"mousedown\", \"mouseeenter\", \"mouseleave\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"mouseleave\", \"mousewheel\");\n            else if (types[i] === \"key\")\n                push(result, \"keydown\", \"keyup\", \"keypress\", \"textInput\");\n            else if (types[i] === \"touch\")\n                push(result, \"touchstart\", \"touchmove\", \"touchend\", \"touchcancel\");\n            else if (types[i] === \"pointer\")\n                push(result, \"pointerover\", \"pointerout\", \"pointerenter\", \"pointerleave\", \"pointerdown\", \"pointerup\", \"pointermove\", \"pointercancel\", \"gotpointercapture\", \"lostpointercapture\");\n            else if (types[i] === \"control\")\n                push(result, \"resize\", \"scroll\", \"zoom\", \"focus\", \"blur\", \"select\", \"input\", \"change\", \"submit\", \"reset\");\n            else\n                push(result, types[i]);\n        }\n        return result;\n    },\n\n    /**\n     * @param {!Event} event\n     */\n    _logEvent: function(event)\n    {\n        inspectedGlobalObject.console.log(event.type, event);\n    }\n}\n\ninjectedScript._commandLineAPIImpl = new CommandLineAPIImpl();\nreturn injectedScript;\n})\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/tools/annotate-tag.js":"'use strict';\n\nconst co = require('co');\nconst exec = require('./exec');\n\nmodule.exports = co.wrap(function * (version) {\n  const history = yield require('./history')(version);\n  const tagname = 'v' + version;\n\n  return yield exec('git tag -a \"' + tagname + '\" -m \"' + history + '\"');\n});\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/tools/exec.js":"'use strict';\n\nconst exec = require('child_process').exec;\n\nmodule.exports =\n  (expression) => new Promise(\n  (resolve, reject) => exec(expression,\n  (error, result) => error ? reject(error) : resolve(String(result).trim())\n));\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/tools/commit-changes.js":"'use strict';\n\nconst exec = require('./exec');\nconst changed = [/*'ChangeLog.md',*/ 'package.json'].join(' ');\n\nmodule.exports =\n  (version) => exec('git commit -m \"' + version + '\" ' + changed);\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/tools/history.js":"'use strict';\n\nconst co = require('co');\nconst exec = require('./exec');\n\nmodule.exports = co.wrap(function * () {\n  const _lasttag = yield exec('git rev-list --tags --max-count=1');\n  const _version = yield exec('git describe --tags --abbrev=0 ' + _lasttag);\n  const version = _version ? ' ' + _version + '..' : '';\n\n  return ' ' + (yield exec('git log --no-merges --pretty=\"format: * %s (%an) %H%n\"' + version));\n});\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/tools/prepublish-to-npm.js":"'use strict';\n\nconst co = require('co');\nconst rimraf = require('rimraf');\nconst gyp = require('node-pre-gyp');\nconst versions = ['0.10.0', '0.12.0', '4.0.0', '5.0.0', '6.0.0'];\nconst matrix = {\n  x64: ['win32', 'linux', 'darwin'],\n  ia32: ['win32']\n};\n\nclass Target {\n  constructor(arch, platform, version) {\n    this.target = version;\n    this.target_platform = platform;\n    this.target_arch = arch;\n  }\n}\n\nconst install = target => new Promise((resolve, reject) => {\n  const prog = Object.assign(new gyp.Run(), {opts: target});\n\n  prog.commands.install([], error => error ? reject(error) : resolve());\n});\n\nmodule.exports = co.wrap(function * () {\n  rimraf.sync('./build');\n\n  const targets = [];\n  Object.keys(matrix).forEach(\n    (arch) => matrix[arch].forEach(\n    (platform) => versions.forEach(\n    (version) => targets.push(new Target(arch, platform, version))\n  )));\n\n  while (targets.length) yield install(targets.pop());\n});\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/tools/publish-to-npm.js":"'use strict';\n\nconst exec = require('./exec');\n\nmodule.exports =\n  (version) => exec('npm publish');\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/tools/push-to-githab.js":"'use strict';\n\nconst exec = require('./exec');\n\nmodule.exports =\n  (version) => exec('git push && git push origin \"v' + version + '\"');\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/tools/release.js":"'use strict';\n\nconst co = require('co');\nconst args = process.argv.slice(2);\nconst version = args.splice(0, 1);\n\nconst npm = require('./update-npm-version');\nconst changelog = require('./update-changelog');\nconst tag = require('./annotate-tag');\nconst commit = require('./commit-changes');\nconst push = require('./push-to-githab');\n\nconst prepublish = require('./prepublish-to-npm');\nconst publish = require('./publish-to-npm');\n\nconst EXAMPLE = ' Example:\\n' +\n  'node release.js 1.0.0 --build\\n' +\n  'node release.js 1.0.0 --publish'\n\nconst SEMVER = /^\\d+(\\.\\d+(\\.\\d+(-.*)?)?(-.*)?)?(-.*)?$/;\n\nconsole.assert(version, 'Wrong usage.' + EXAMPLE);\nconsole.assert(SEMVER.test(version), version + ' is not correct semver');\n\nconst BUILD = args.some(\n  (arg) => /^(-b|--build)$/.test(arg));\n\nconst PUBLISH = args.some(\n  (arg) => /^(-p|--publish)$/.test(arg));\n\nconsole.assert(BUILD || PUBLISH, 'No mode selected.' + EXAMPLE);\n\nreturn co(function * () {\n  if (BUILD) {\n    console.log('--Update the version in package.json--');\n    yield npm(version);\n\n    // TODO: enable changelog on 1.0 version\n    // console.log('--Update ChangeLog.md--');\n    // changelog();\n\n    console.log('--Commit the changes--');\n    yield commit(version);\n\n    console.log('--Tag the release--')\n    yield tag(version);\n\n    console.log('--Push to github--');\n    yield push(version);\n  } else if (PUBLISH) {\n    console.log('--Download prebuilt binaries--');\n    yield prepublish();\n\n    console.log('--Publish to npm--');\n    yield publish();\n  }\n}).catch((error) => {\n  console.error(error.stack);\n  return process.exit(1);\n});\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/tools/update-changelog.js":"var fs = require('fs');\nvar exists = fs.existsSync;\nvar read = fs.readFileSync;\nvar write = fs.writeFileSync;\n\nvar history = require('./history');\n\nmodule.exports = function changelog(filename) {\n  filename = filename || 'CHANGELOG.md';\n\n  var _changelog = exists(filename) ? read(filename) : '';\n  var _history = history();\n\n  write(filename, _history + '\\n' + _changelog);\n};\n\n//test -n \"$EDITOR\" && $EDITOR $CHANGELOG\n","/home/travis/build/npmtest/node-npmtest-v8-debug/node_modules/v8-debug/tools/update-npm-version.js":"'use strict';\n\nconst exec = require('./exec');\n\nmodule.exports =\n  (version) => exec('npm version --git-tag-version=false \"' + version + '\"');\n"}